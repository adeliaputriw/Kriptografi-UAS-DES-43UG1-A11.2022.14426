# -*- coding: utf-8 -*-
"""UAS DES.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18Vgt6yjClt1EXcS3ExvY3dNwXssB-HUG

Proses Encoding File ke Base64
"""

import base64
import os

# Fungsi untuk membaca file dan mengonversinya ke format Base64
def file_to_base64(file_path):
    with open(file_path, "rb") as file:
        # Baca file sebagai bytes
        file_binary = file.read()

        # Encode file ke dalam format Base64
        file_base64 = base64.b64encode(file_binary).decode("utf-8")

    return file_base64

# Fungsi untuk menyimpan hasil encoding Base64 ke dalam file teks
def save_base64_to_text(base64_data, output_path):
    with open(output_path, "w") as base64_file:
        base64_file.write(base64_data)

file_path = input("Masukkan path file yang akan di-encoding: ")

file_extension = os.path.splitext(file_path)[1]  # Mendapatkan ekstensi file
base64_data = file_to_base64(file_path)
# text_file_path = input("Masukkan path untuk menyimpan hasil encoding (contoh: hasil_encoding.txt): ")

# Dapatkan direktori dari path file
text_file_path = "hasil/hasil_encoding.txt"
folder_path = os.path.dirname(text_file_path)
# Cek apakah folder sudah ada, jika belum, buat folder baru
if not os.path.exists(folder_path):
    os.makedirs(folder_path)

save_base64_to_text(base64_data, text_file_path)
print(f"Hasil encoding berhasil disimpan pada file '{text_file_path}'")

"""Proses Binerisasi"""

# Fungsi untuk binerisasi file teks
def binarize_file_text(input_path, output_path):
    with open(input_path, 'r') as file:
        # Baca seluruh konten file
        content = file.read()

    # Konversi teks ke biner
    # binary_data = ' '.join(format(ord(char), '08b') for char in content)
    binary_data = ''.join(format(ord(char), '08b') for char in content)

    # Simpan hasil binerisasi ke dalam file
    with open(output_path, 'w') as bin_file:
        bin_file.write(binary_data)

input_path = "hasil/hasil_encoding.txt"
# hapus komen ini untuk menginputkan path file secara manual
# input_path = input("Masukkan path file teks untuk binerisasi: ")
# output_path = input("Masukkan path untuk menyimpan hasil binerisasi (contoh: hasil_binerisasi.txt): ")

output_path = "hasil/hasil_binerisasi.txt" # komen ini jika ingin menginputkan file secara manual
binarize_file_text(input_path, output_path)
print(f"Hasil encoding berhasil disimpan pada file '{output_path}'")

"""Proses Generate Kunci"""

# Fungsi untuk mengubah karakter ke biner
from turtle import left


def ascii_to_binary(ascii_string):
    binary = ''
    for char in ascii_string:
        # Konversi setiap karakter ASCII ke binary 8-bit
        binary += format(ord(char), '08b')
    return binary

# Fungsi untuk shifting
def shifted(bits, shift):
    result = bits[shift:] + bits[:shift]
    return result

# Fungsi untuk permutasi menggunakan tabel
def permute(data, permutation_table, length_of_output):
    # data, tabel permutasi, ukuran tabel permutasi
    permutation = ''
    for i in range(length_of_output):
        permutation += data[permutation_table[i] - 1]
    return permutation

# Fungsi untuk generate kunci
def generate_keys(initial_key):
    # hapus komen ini untuk menginputkan path file secara manual
    # output_filename = input("Masukkan nama file untuk menyimpan hasil generate kunci: ")
    output_filename = "proses/proses_generatekey.txt"   # komen ini jika ingin menginputkan file secara manual
    folder_path = os.path.dirname(output_filename)
    # Cek apakah folder sudah ada, jika belum, buat folder baru
    if not os.path.exists(folder_path):
        os.makedirs(folder_path)
    with open(output_filename, 'w') as file:
        print(f"\nGenerate kunci berhasil. Hasil proses tersimpan dalam file '{output_filename}'.\n")

        # Kondisi jika panjang kunci tidak sesuai
        if len(initial_key)*8 != 64:
            raise ValueError("Panjang kunci harus 64 bit (8 karakter ASCII)")

        # Konversi ASCII ke binary
        binary_key = ascii_to_binary(initial_key)

        # Menampilkan hasil output
        print("Kunci : ",initial_key)
        print(f"Biner kunci : {binary_key}")

        # Menyimpan hasil output pada file
        file.write(f"Kunci awal : {initial_key}\n")
        file.write(f"Biner kunci :{binary_key}\n")

        # Tabel Permutation Choice 1 (PC1)
        pc1_table = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2,
                    59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39,
                    31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37,
                    29, 21, 13, 5, 28, 20, 12, 4]

        # Apply Permutation Choice 1 (PC1)
                    # data, permutation_table, length_of_output
        key = permute(binary_key, pc1_table, 56)
        file.write(f"\nBiner kunci setelah dipermutasi PC1: \n{key}")

        # Split hasil kunci menjadi 4 bagian
        left_half = key[:28]
        right_half = key[28:]

        file.write("\nMembagi hasil permutasi menjadi 2 bagian:\n")
        file.write(f"Left Half: {left_half}\n")
        file.write(f"Right Half: {right_half}\n")

        # Untuk menyimpan hasil key schedule 16x putaran
        shift_results = []
        key_schedule = []

        # Jumlah pergeseran
        round_shifts = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]

        # Permutation Choice 2 (PC2)
        pc2_table = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4,
                    26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40,
                    51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]

        file.write("\n===================\nProses Pergeseran\n===================\n")
        # Generate kunci setiap putaran
        for index, round_shift in enumerate(round_shifts):
            left_half = shifted(left_half, round_shift)
            right_half = shifted(right_half, round_shift)

            file.write(f"\nPergeseran ke-{index+1} \n")
            file.write(f"Jumlah Pergeseran: {round_shift}\n")
            file.write(f"Bagian 1: {left_half}\n")
            file.write(f"Bagian 2: {right_half}\n")

            # Menuliskan hasil gabungan setelah pergeseran ke file
            shift_result = left_half + right_half
            # Menyimpan hasil gabungan setelah pergeseran ke list shift_results
            shift_results.append(shift_result)

            # Menyimpan hasil key schedule (hasil shift yang sudah di permutasi dengan tabel pc2)
                                # data, permutation_table, length_of_output
            key_schedule.append(permute(shift_result, pc2_table, 48))


        print("\n===================================\nHasil Putaran Kunci (Key Schedule)\n===================================")

        file.write("\n\n===================================\n")
        file.write("Hasil gabungan setelah pergeseran")
        file.write("\n=====================================\n")
        for i, shift_result in enumerate(shift_results):
            file.write(f"Shift ke {i + 1}: {key}\n")

        # Menulis hasil key schedule ke file
        file.write("\n\n===================================\n")
        file.write("Hasil Putaran Kunci (Key Schedule)")
        file.write("\n=====================================\n")
        for i, key in enumerate(key_schedule):
            file.write(f"Putaran ke {i + 1}: {key}\n")
            print(f"Putaran ke {i + 1}: {key}")

        # Mengembalikan key_schedule
        return key_schedule

initial_key = input("Masukkan kunci: ")
keys = generate_keys(initial_key)

"""Proses Enkripsi"""

# Fungsi XOR
def xor(a,b):
    store = ''
    for i in range(len(a)):
        store += str((int(a[i]) + int(b[i])) % 2)
    return store

# Mengubah binary yang tipe datanya string ke int agar bisa diolah nilainya
def bin_to_int(binary_string):
    length = len(binary_string) - 1
    number = 0
    for bin in range(length + 1):
        number += int(binary_string[bin]) * (2 ** (length - bin))
    return number

# Mengubah integer ke binary
def int_to_bin(integer):
    return bin(integer)[2:]

#  Fungsi untuk permutasi menggunakan tabel
def permute(data, permutation_table, length_of_output):
    permutation = ''
    for i in range(length_of_output):
        permutation += data[permutation_table[i] - 1]
    return permutation

# Tabel Inital and Final Permuttions
def IP(data):
    initial_perm = [58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4,62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8,
                    57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7]
    return permute(data, initial_perm, 64)

def IP_Inverse(data):
    inverse_perm = [40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29,
                    36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25]
    return permute(data, inverse_perm, 64)


#  Fungsi untuk manipulasi dalam fungsi feistel
def f_expansion(bits):
    # Permutasi ini memperluas input menjadi 48 bit dan memberikan lapisan 'confusion'
    expansion_perm = [32, 1 , 2 , 3 , 4 , 5 , 4 , 5, 6 , 7 , 8 , 9 , 8 , 9 , 10, 11, 12, 13, 12, 13, 14, 15, 16, 17,
                      16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1 ]
    return permute(bits, expansion_perm, 48)

# Fungsi untuk XOR kunci dan pesan
def f_key_mixing(bits, key):
    return xor(bits, key)


def s_boxes(bits):
    # Subtitusi menggunakan s-box dengan mengambil enam bit input dan memetakkannya ke empat bit output
    sboxes =   [[[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7], [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8], [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0], [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13 ]],
                [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10], [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5], [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15], [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9 ]],
                [[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8], [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1], [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7], [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12 ]],
                [[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15], [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9], [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4], [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14 ]],
                [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9], [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6], [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14], [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3 ]],
                [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11], [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8], [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6], [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13 ]],
                [[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1], [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6], [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2], [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12 ]],
                [[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7], [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2], [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8], [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11 ]]]
    # Bagi byte menjadi 8 substring, bagi substring tersebut menjadi bit luar dan dalam,
    # dan gunakan sebagai indeks untuk pencarian di sboxes, konversi ke biner dan tambahkan nol jika diperlukan.
    substituted_string = ''
    for i in range(0,48,6):
        substring = (bits[0:48][i:i+6])
        row = bin_to_int(substring[0] + substring[5])
        column = bin_to_int(substring[1] + substring[2] + substring[3] + substring[4])
        lookup = int_to_bin(sboxes[int(i/6)][row][column])
        if len(lookup) < 4:
            lookup = ((4 - len(lookup)) * '0') + lookup
        substituted_string += lookup

    return substituted_string

# Fungsi Feistel termasuk permutasi akhir, untuk menambahkan 'confusion' tambahan dalam setiap putaran.
def f_permute(bits):
    p_box = [16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25]
    return permute(bits, p_box, 32)

# Fungsi Feistel yang dipanggil saat enkripsi
def f(bytes, key): # bytes = right_half , 32 bit
    expanded = f_expansion(bytes)
    mixed = f_key_mixing(expanded, key)
    substituted = s_boxes(mixed)
    permutation = f_permute(substituted)
    return permutation

# Membagi setiap putaran
def round(left_half, right_half, key):
    new_right_half = xor(left_half, f(right_half, key))
    return right_half, new_right_half

# Fungsi untuk mengenkripsi 64bit blok
def encrypt_block(block, keys, output_file):
    key_schedule = keys
    perm = IP(block)
    left_half, right_half = perm[0:32], perm[32:64]

    output_file.write(' ' * 20 + 'Part 1' + ' ' * 20 + 'Part 2' + ' ' * 20 + 'Sub Key\n')
    for loop in range(16):
        left_half, right_half = round(left_half, right_half, key_schedule[loop])
        if 9 <= loop <= 14:
            output_file.write(f'Round: {loop + 1}    {left_half} {right_half} {key_schedule[loop]}\n')
        if 0 <= loop <= 8:
            output_file.write(f'Round: {loop + 1}   {left_half} {right_half} {key_schedule[loop]}\n')
        if loop == 15:
            output_file.write(f'Round: Swap  {right_half} {left_half} {key_schedule[loop]}\n\n')


    block_ciphertext = IP_Inverse(right_half+ left_half)
    output_file.write(f"Ciphertext pada blok saat ini: {block_ciphertext}\n\n")
    return block_ciphertext

# Fungsi untuk mengenkripsi 64bit blok
def encrypt_from_file(input_filename, keys, process_filename, result_filename):
    with open(input_filename, 'r') as input_file, open(process_filename, 'w') as process_file:
        message = input_file.read()
        # Untuk memastikan bahwa pesan merupakan string
        if not isinstance(message, str):
            return 'ERROR: Pesan harus berupa string'

        binary_message = message

        # Memberikan padding 0 jika dibutuhkan agar pas 64bit
        if len(binary_message) % 64 != 0:
            padding_length = 64 - (len(binary_message) % 64)
            binary_message += '0' * padding_length

        ciphertext = ''
        num_blocks = len(binary_message) // 64

        for block_num in range(num_blocks):
            block_start = block_num * 64
            block_end = (block_num + 1) * 64
            block = binary_message[block_start:block_end]

            # Enkripsi setiap blok dengan terpisah
            block_ciphertext = encrypt_block(block, keys, process_file)
            ciphertext += block_ciphertext

    # Menyimpan hasil
    with open(result_filename, 'w') as result_file:
        result_file.write(ciphertext)

    print(f"Hasil enkripsi berhasil disimpan ke dalam file '{result_filename}'.")
    return ciphertext


# plaintext_filename = input("Masukkan nama file yang akan dienkripsi: ")
plaintext_filename = "hasil/hasil_binerisasi.txt"
process_filename = "proses/proses_enkripsi.txt"
result_filename = "hasil/hasil_enkripsi.txt"

print(f"Proses enkripsi berhasil disimpan ke dalam file '{process_filename}'.")
ciphertext = encrypt_from_file(plaintext_filename, keys, process_filename, result_filename)
print("Ciphertext:", ciphertext)

"""Proses Dekripsi"""

# Fungsi untuk mendekripsi 64bit blok
def decrypt_block(block, keys, output_file):
    key_schedule = keys
    perm = IP(block)
    left_half, right_half = perm[0:32], perm[32:64]

    output_file.write(' ' * 20 + 'Part 1' + ' ' * 20 + 'Part 2' + ' ' * 20 + 'Sub Key\n')

    for loop in range(15, -1, -1):  # Membalik urutan dekripsi
        left_half, right_half = round(left_half, right_half, key_schedule[loop])
        if 9 <= loop <= 15:
            output_file.write(f'Round: {loop + 1}  {left_half} {right_half} {key_schedule[loop]}\n')
        if 0 <= loop <= 8:
            output_file.write(f'Round: {loop + 1} {left_half} {right_half} {key_schedule[loop]}\n')
    output_file.write(f'Round: Swap  {right_half} {left_half} {key_schedule[loop]}\n\n')

    block_plaintext = IP_Inverse(right_half + left_half)
    output_file.write(f"Plaintext for this block: {block_plaintext}\n\n")
    return block_plaintext

# Fungsi yang sudah dimodifikasi untuk mendekripsi pesan yang lebih panjang
def decrypt_from_file(input_filename, key, output_filename):
    with open(input_filename, 'r') as input_file, open(output_filename, 'w') as output_file:
        ciphertext = input_file.read()
        # Untuk memastikan bahwa pesan merupakan string
        if not isinstance(ciphertext, str):
            return 'ERROR: Ciphertext should be a string'

        # Memberikan padding 0 jika dibutuhkan agar pas 64bit
        if len(ciphertext) % 64 != 0:
            padding_length = 64 - (len(ciphertext) % 64)
            ciphertext += '0' * padding_length

        plaintext = ''
        num_blocks = len(ciphertext) // 64

        for block_num in range(num_blocks):
            block_start = block_num * 64
            block_end = (block_num + 1) * 64
            block = ciphertext[block_start:block_end]

            # Dekripsi setiap blok dengan terpisah
            block_plaintext = decrypt_block(block, key, output_file)
            plaintext += block_plaintext

        print(f"Proses dekripsi berhasil disimpan ke dalam file '{output_filename}'")

    return plaintext

# Example usage
ciphertext_filename = "hasil/hasil_enkripsi.txt"
decrypted_output_filename = "proses/proses_dekripsi.txt"
decrypted = decrypt_from_file(ciphertext_filename, keys, decrypted_output_filename)

binary_data = ''.join([decrypted[i:i+8] for i in range(0, len(decrypted), 8)])
output_filename = "hasil/hasil_dekripsi.txt"

with open(output_filename, 'w') as file:
    print(f"\nHasil dekripsi berhasil disimpan ke dalam file '{output_filename}'.\n")
    file.write(binary_data)

"""Konversi hasil biner ke teks"""

# Fungsi untuk konversi dari biner ke teks
def binary_to_text(binary_data):
    # Pisahkan biner menjadi blok 8-bit dan konversi ke karakter ASCII
    binary_blocks = [binary_data[i:i+8] for i in range(0, len(binary_data), 8)]
    text_data = ''.join(chr(int(block, 2)) for block in binary_blocks)

    # Hilangkan karakter null
    text_data = text_data.replace('\x00', '')

    return text_data

# Fungsi untuk membaca file biner dan menyimpan teks
def bin_to_text(input_path, output_path):
    with open(input_path, 'r') as bin_file:
        # Baca seluruh konten file
        binary_data = bin_file.read()

    # Konversi dari biner ke teks
    text_data = binary_to_text(binary_data)

    # Simpan hasil konversi ke dalam file teks
    with open(output_path, 'w') as text_file:
        text_file.write(text_data)

# Contoh penggunaan fungsi
input_path = "hasil/hasil_dekripsi.txt"
output_path = "hasil/hasil_decoding.txt"

bin_to_text(input_path, output_path)
print(f"Hasil decoding berhasil disimpan pada file '{output_path}'")

"""Membandingkan hasil encoding dan decoding"""

# file1_path = input("Masukkan path file asli: ")
# file2_path = input("Masukkan path hasil dekripsi (contoh: hasil_dekripsi.txt): ")

file1_path = "hasil/hasil_encoding.txt"
file2_path = "hasil/hasil_decoding.txt"

def are_files_equal(file1_path, file2_path):
    with open(file1_path, 'r') as file1, open(file2_path, 'r') as file2:
        content1 = file1.read()
        content2 = file2.read()

    if content1 == content2:
        return True
    else:
        return False

if are_files_equal(file1_path, file2_path):
    print("Isi kedua file sama.")
else:
    print("Isi kedua file tidak sama.")

"""Hasil konversi ke file asli"""

import os
import base64

# Fungsi untuk mendekode teks Base64 dan menyimpannya ke dalam file
def base64_to_file(base64_data, output_path):
    # Decode Base64 ke dalam bytes
    file_binary = base64.b64decode(base64_data.encode("utf-8"))

    # Simpan file ke dalam path yang diberikan
    with open(output_path, "wb") as file:
        file.write(file_binary)

# Masukkan path file teks Base64 hasil dekripsi
# base64_text_path = input("Masukkan path hasil dekripsi (contoh: hasil_dekripsi.txt): ")
base64_text_path = "hasil/hasil_decoding.txt"

# Baca teks Base64 dari file
with open(base64_text_path, 'r') as file:
    base64_message = file.read()

# Masukkan path untuk menyimpan file hasil decoding
# output_file_path = input("Masukkan path untuk menyimpan file hasil decoding (contoh: hasil_file.jpeg): ")
output_file_path = "hasil/hasil_file.jpeg"


# Panggil fungsi untuk mendecode dan menyimpan file
base64_to_file(base64_message, output_file_path)

print(f"File berhasil disimpan pada '{output_file_path}'")